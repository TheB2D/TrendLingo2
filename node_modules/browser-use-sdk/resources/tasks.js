"use strict";
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tasks = void 0;
const resource_1 = require("../core/resource.js");
const path_1 = require("../internal/utils/path.js");
const parse_1 = require("../lib/parse.js");
const stream_1 = require("../lib/stream.js");
const types_1 = require("../lib/types.js");
class Tasks extends resource_1.APIResource {
    create(body, options) {
        if ('schema' in body && body.schema != null && typeof body.schema === 'object') {
            const schema = body.schema;
            const _body = {
                ...body,
                structuredOutputJson: (0, parse_1.stringifyStructuredOutput)(schema),
            };
            return this._client.post('/tasks', { body: _body, ...options });
        }
        return this._client.post('/tasks', { body, ...options });
    }
    retrieve(req, options) {
        if (typeof req === 'string') {
            return this._client.get((0, path_1.path) `/tasks/${req}`, options);
        }
        const { taskId, schema } = req;
        return this._client
            .get((0, path_1.path) `/tasks/${taskId}`, options)
            ._thenUnwrap((rsp) => (0, parse_1.parseStructuredTaskOutput)(rsp, schema));
    }
    async *watch(taskId, config, options) {
        const hash = { current: null };
        poll: do {
            if (options?.signal?.aborted) {
                break poll;
            }
            const res = await this.retrieve(taskId);
            const resHash = (0, stream_1.getTaskViewHash)(res);
            if (hash.current == null || resHash !== hash.current) {
                hash.current = resHash;
                yield { event: 'status', data: res };
            }
            switch (res.status) {
                case 'finished':
                case 'stopped':
                case 'paused':
                    break poll;
                case 'started':
                    await new Promise((resolve) => setTimeout(resolve, config.interval));
                    break;
                default:
                    throw new types_1.ExhaustiveSwitchCheck(res.status);
            }
        } while (true);
    }
    async *stream(body, options) {
        const taskId = typeof body === 'object' ? body.taskId : body;
        for await (const msg of this.watch(taskId, { interval: 500 }, options)) {
            if (options?.signal?.aborted) {
                break;
            }
            if (typeof body === 'object') {
                const parsed = (0, parse_1.parseStructuredTaskOutput)(msg.data, body.schema);
                yield { event: 'status', data: parsed };
            }
            else {
                yield { event: 'status', data: msg.data };
            }
        }
    }
    run(body, options) {
        if ('schema' in body && body.schema != null && typeof body.schema === 'object') {
            return this.create(body, options)._thenUnwrap(async (data) => {
                const taskId = data.id;
                for await (const msg of this.stream({ taskId, schema: body.schema }, options)) {
                    if (msg.data.status === 'finished') {
                        return msg.data;
                    }
                }
                throw new Error('Task did not finish');
            });
        }
        return this.create(body, options)._thenUnwrap(async (data) => {
            const taskId = data.id;
            for await (const msg of this.stream(taskId, options)) {
                if (msg.data.status === 'finished') {
                    return msg.data;
                }
            }
            throw new Error('Task did not finish');
        });
    }
    /**
     * Control the execution of an AI agent task.
     *
     * Allows you to pause, resume, or stop tasks, and optionally stop the entire
     * session. This is useful for:
     *
     * - Pausing long-running tasks to review progress
     * - Stopping tasks that are taking too long
     * - Ending sessions when you're done with all tasks
     *
     * Available actions:
     *
     * - STOP: Stop the current task
     * - PAUSE: Pause the task (can be resumed later)
     * - RESUME: Resume a paused task
     * - STOP_TASK_AND_SESSION: Stop the task and end the entire session
     *
     * Args:
     *
     * - task_id: The unique identifier of the agent task to control
     * - request: The action to perform on the task
     *
     * Returns:
     *
     * - The updated task information
     *
     * Raises:
     *
     * - 404: If the user agent task doesn't exist
     */
    update(taskID, body, options) {
        return this._client.patch((0, path_1.path) `/tasks/${taskID}`, { body, ...options });
    }
    /**
     * Get a paginated list of all Browser Use Agent tasks for the authenticated user.
     *
     * Browser Use Agent tasks are the individual jobs that your agents perform within
     * a session. Each task represents a specific instruction or goal that the agent
     * works on, such as filling out a form, extracting data, or navigating to specific
     * pages.
     *
     * Returns:
     *
     * - A paginated list of Browser Use Agent tasks
     * - Total count of Browser Use Agent tasks
     * - Page information for navigation
     */
    list(query = {}, options) {
        return this._client.get('/tasks', { query, ...options });
    }
    /**
     * Get a download URL for the execution logs of an AI agent task.
     *
     * Task logs contain detailed information about how the AI agent executed the task,
     * including:
     *
     * - Step-by-step reasoning and decisions
     * - Actions taken on web pages
     * - Error messages and debugging information
     * - Performance metrics and timing data
     *
     * This is useful for:
     *
     * - Understanding how the agent solved the task
     * - Debugging failed or unexpected results
     * - Optimizing agent behavior and prompts
     * - Auditing agent actions for compliance
     *
     * Args:
     *
     * - task_id: The unique identifier of the agent task
     *
     * Returns:
     *
     * - A presigned download URL for the task log file
     *
     * Raises:
     *
     * - 404: If the user agent task doesn't exist
     * - 500: If the download URL cannot be generated (should not happen)
     */
    getLogs(taskID, options) {
        return this._client.get((0, path_1.path) `/tasks/${taskID}/logs`, options);
    }
    /**
     * Get a download URL for a specific output file generated by an AI agent task.
     *
     * AI agents can generate various output files during task execution, such as:
     *
     * - Screenshots of web pages
     * - Extracted data in CSV/JSON format
     * - Generated reports or documents
     * - Downloaded files from websites
     *
     * This endpoint provides a secure, time-limited download URL for accessing these
     * files. The URL expires after a short time for security.
     *
     * Args:
     *
     * - task_id: The unique identifier of the agent task
     * - file_id: The unique identifier of the output file
     *
     * Returns:
     *
     * - A presigned download URL for the requested file
     *
     * Raises:
     *
     * - 404: If the user agent task or output file doesn't exist
     * - 500: If the download URL cannot be generated (should not happen)
     */
    getOutputFile(fileID, params, options) {
        const { task_id } = params;
        return this._client.get((0, path_1.path) `/tasks/${task_id}/output-files/${fileID}`, options);
    }
    /**
     * Get a download URL for a specific user uploaded file that was used in the task.
     *
     * A user can upload files to their account file bucket and reference the name of
     * the file in a task. These files are then made available for the agent to use
     * during the agent task run.
     *
     * This endpoint provides a secure, time-limited download URL for accessing these
     * files. The URL expires after a short time for security.
     *
     * Args:
     *
     * - task_id: The unique identifier of the agent task
     * - file_id: The unique identifier of the user uploaded file
     *
     * Returns:
     *
     * - A presigned download URL for the requested file
     *
     * Raises:
     *
     * - 404: If the user agent task or user uploaded file doesn't exist
     * - 500: If the download URL cannot be generated (should not happen)
     */
    getUserUploadedFile(fileID, params, options) {
        const { task_id } = params;
        return this._client.get((0, path_1.path) `/tasks/${task_id}/user-uploaded-files/${fileID}`, options);
    }
}
exports.Tasks = Tasks;
//# sourceMappingURL=tasks.js.map