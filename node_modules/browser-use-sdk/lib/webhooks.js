"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zWebhookSchema = exports.zWebhookAgentTaskStatusUpdate = exports.zWebhookAgentTaskStatusUpdatePayload = exports.zWebhookAgentTaskStatusUpdatePayloadStatus = exports.zWebhookAgentTaskStatusUpdatePayloadMetadata = exports.zWebhookTest = exports.zWebhookTestPayload = exports.zWebhookTimestamp = void 0;
exports.verifyWebhookEventSignature = verifyWebhookEventSignature;
exports.createWebhookSignature = createWebhookSignature;
const tslib_1 = require("../internal/tslib.js");
const crypto_1 = require("crypto");
const zod_1 = require("zod");
const fast_json_stable_stringify_1 = tslib_1.__importDefault(require("fast-json-stable-stringify"));
// https://docs.browser-use.com/cloud/webhooks
//
exports.zWebhookTimestamp = zod_1.z.iso.datetime({ offset: true, local: true });
// test
exports.zWebhookTestPayload = zod_1.z.object({
    test: zod_1.z.literal('ok'),
});
exports.zWebhookTest = zod_1.z.object({
    type: zod_1.z.literal('test'),
    timestamp: exports.zWebhookTimestamp,
    payload: exports.zWebhookTestPayload,
});
// agent.task.status_update
exports.zWebhookAgentTaskStatusUpdatePayloadMetadata = zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()).optional();
exports.zWebhookAgentTaskStatusUpdatePayloadStatus = zod_1.z.literal([
    'initializing',
    'started',
    'paused',
    'stopped',
    'finished',
]);
exports.zWebhookAgentTaskStatusUpdatePayload = zod_1.z.object({
    session_id: zod_1.z.string(),
    task_id: zod_1.z.string(),
    status: exports.zWebhookAgentTaskStatusUpdatePayloadStatus,
    metadata: exports.zWebhookAgentTaskStatusUpdatePayloadMetadata,
});
exports.zWebhookAgentTaskStatusUpdate = zod_1.z.object({
    type: zod_1.z.literal('agent.task.status_update'),
    timestamp: exports.zWebhookTimestamp,
    payload: exports.zWebhookAgentTaskStatusUpdatePayload,
});
//
exports.zWebhookSchema = zod_1.z.discriminatedUnion('type', [
    //
    exports.zWebhookTest,
    exports.zWebhookAgentTaskStatusUpdate,
]);
// Signature
/**
 * Utility function that validates the received Webhook event/
 */
async function verifyWebhookEventSignature(evt, cfg) {
    try {
        const json = typeof evt.body === 'string' ? JSON.parse(evt.body) : evt.body;
        const event = await exports.zWebhookSchema.safeParseAsync(json);
        if (event.success === false) {
            return { ok: false };
        }
        const signature = createWebhookSignature({
            payload: event.data.payload,
            timestamp: evt.timestamp,
            secret: cfg.secret,
        });
        // Compare signatures using timing-safe comparison
        if (evt.signature !== signature) {
            return { ok: false };
        }
        return { ok: true, event: event.data };
    }
    catch (err) {
        console.error(err);
        return { ok: false };
    }
}
/**
 * Creates a webhook signature for the given payload, timestamp, and secret.
 */
function createWebhookSignature({ payload, timestamp, secret, }) {
    const dump = (0, fast_json_stable_stringify_1.default)(payload);
    const message = `${timestamp}.${dump}`;
    const hmac = (0, crypto_1.createHmac)('sha256', secret);
    hmac.update(message);
    return hmac.digest('hex');
}
//# sourceMappingURL=webhooks.js.map